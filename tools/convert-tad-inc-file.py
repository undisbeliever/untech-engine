#!/usr/bin/env python3

import re
import sys
import json
import argparse

from io import StringIO
from typing import Any, Final, NamedTuple

HEADER = """
// Terrific Audio Driver LoadSongData and audio driver/data include statements.
//
// This file is automatically generated by `gen-tad-include-file.py`
//
// It MUST BE recreated if the audio project has changed (including samples, sound effects and songs).
//

// SPDX-License-Identifier: Unlicense
//
// This is free and unencumbered software released into the public domain.
//
// Anyone is free to copy, modify, publish, use, compile, sell, or distribute this software, either in
// source code form or as a compiled binary, for any purpose, commercial or non-commercial, and by any
// means.
//
// In jurisdictions that recognize copyright laws, the author or authors of this software dedicate any
// and all copyright interest in the software to the public domain. We make this dedication for the
// benefit of the public at large and to the detriment of our heirs and successors. We intend this
// dedication to be an overt act of relinquishment in perpetuity of all present and future rights to
// this software under copyright law.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
// NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
// For more information, please refer to <http://unlicense.org/>

"""


class Mapping(NamedTuple):
    name: str
    offset: int
    load_audio_data: str


MAPPINGS: Final = {
    "LOROM": Mapping(
        name="LOROM",
        offset=0x8000,
        load_audio_data="""
// LoadAudioData callback (LOROM mapping)
//
// Called using JSL (return with RTL)
//
// IN: A = 0 - Common audio data (MUST return carry set)
// IN: A >= 1 - Song data (might be invalid)
// OUT: Carry set if input (`A`) was valid
// OUT: A:X = far address
// OUT: Y = size
a8()
i16()
// DB unknown
code(TadData0)
function LoadAudioData {
    assert(MEMORY_MAP.{MEMORY_MAP} == MEMORY_MAP.LOROM)
    assert(N_TAD_DATA_ITEMS > 1)

    constant AUDIO_DATA_BANK = Tad_DataTable >> 16


    cmp.b   #N_TAD_DATA_ITEMS
    bcc     +
        // return false
        clc
        rtl
    +

    rep     #$30
a16()
    and.w   #$ff

    pha

    asl
    // carry clear
    adc     1,s
    tax

    // Calculate data size
    // ASSUMES data size > 0 and <= $ffff
    lda.l   Tad_DataTable+3,x
    sec
    sbc.l   Tad_DataTable,x
    tay

    lda.l   Tad_DataTable,x
    cmp.w   #$8000
    ora.w   #$8000
    sta     1,s

    // carry = bit 0 of bank byte

    sep     #$20
a8()
    lda,l   Tad_DataTable+2,x
    rol
    clc
    adc.b   #AUDIO_DATA_BANK

    plx

    sec
    rtl
}
""",
    ),
    "HIROM": Mapping(
        name="HIROM",
        offset=0x0000,
        load_audio_data="""
// LoadAudioData callback (HIROM mapping)
//
// Called using JSL (return with RTL)
//
// IN: A = 0 - Common audio data (MUST return carry set)
// IN: A >= 1 - Song data (might be invalid)
// OUT: Carry set if input (`A`) was valid
// OUT: A:X = far address
// OUT: Y = size
a8()
i16()
// DB unknown
code(TadData0)
function LoadAudioData {
    assert(MEMORY_MAP.{MEMORY_MAP} == MEMORY_MAP.HIROM)
    assert(N_TAD_DATA_ITEMS > 1)

    constant AUDIO_DATA_BANK = Tad_DataTable >> 16


    cmp.b   #N_TAD_DATA_ITEMS
    bcc     +
        // return false
        clc
        rtl
    +

    rep     #$30
a16()
    and.w   #$ff

    pha

    asl
    // carry clear
    adc     1,s
    tax

    // Calculate data size
    // ASSUMES data size > 0 and <= $ffff
    lda.l   Tad_DataTable+3,x
    sec
    sbc.l   Tad_DataTable,x
    tay

    lda.l   Tad_DataTable,x
    sta     1,s

    sep     #$21
a8()
    lda.l   Tad_DataTable+2,x
    // carry set
    adc.b   #(AUDIO_DATA_BANK - 1) & $ff

    plx

    sec
    rtl
}
""",
    ),
}


def sanitize(s: str) -> str:
    return re.sub(r"[^A-Za-z0-9_]+", "_", s)


def generate_enums(project: dict[str, Any], out: StringIO) -> None:
    out.write("namespace Song {\n  constant BLANK = 0\n")

    for i, s in enumerate(project["songs"]):
        out.write(f"  constant { sanitize(s['name']) } = { i + 1 }\n")

    out.write("}\n\n")

    out.write("namespace SFX {\n")

    sfx = (
        project["high_priority_sound_effects"]
        + project["sound_effects"]
        + project["low_priority_sound_effects"]
    )

    for i, s in enumerate(sfx):
        out.write(f"  constant { sanitize(s) } = { i }\n")

    out.write("}\n\n")


def generate_asm(ca65_asm_file: str, out: StringIO) -> None:
    extract_str = lambda regex: str(
        re.search(regex, ca65_asm_file, re.MULTILINE).group(1)
    )
    extract_constant = lambda regex: int(
        re.search(regex, ca65_asm_file, re.MULTILINE).group(1)
    )

    mapping = MAPPINGS[
        extract_str(r"^;; LoadAudioData callback \((HIROM|LOROM) mapping\)$")
    ]

    tad_loader_size = extract_constant(r"^.export Tad_Loader_SIZE = (\d+)$")
    tad_audiodriver_size = extract_constant(r"^.export Tad_AudioDriver_SIZE = (\d+)$")
    data_table_offset = extract_constant(
        r"^Tad_DataTable := __Tad_AudioData_0 \+ (\d+)$"
    )
    n_data_items = extract_constant(r"^N_DATA_ITEMS = (\d+)$")
    tad_io_version = extract_constant(r".assert TAD_IO_VERSION = (\d+),")
    load_audio_data_size = extract_constant(
        r"^.assert .sizeof\(LoadAudioData\) = (\d+), error$"
    )

    assert data_table_offset == tad_loader_size + tad_audiodriver_size

    out.write(f"constant N_TAD_DATA_ITEMS = {n_data_items}\n")
    out.write(f"constant TAD_IO_VERSION = {tad_io_version}\n")
    out.write("\n")

    out.write("architecture wdc65816-strict")
    out.write(mapping.load_audio_data)
    out.write("architecture none")
    out.write("\n")

    for m in re.finditer(
        r'^\s*__Tad_AudioData_(\d+): \.incbin "([^"]+)", \$([0-9a-f]+), \$([0-9a-f]+)$',
        ca65_asm_file,
        re.MULTILINE,
    ):
        block_id = int(m.group(1))
        filename = str(m.group(2))
        offset = int(m.group(3), 16)
        size = int(m.group(4), 16)

        out.write(
            f"""
rodata(TadData{block_id})
  insert __Tad_AudioData_{block_id}, "{filename}", {offset}, {size}
  assert(pc() & 0xffff == 0)
"""
        )

    last_incbin = re.search(
        r'^\s*__Tad_AudioData_(\d+): \.incbin "([^"]+)", \$([0-9a-f]+)$',
        ca65_asm_file,
        re.MULTILINE,
    )
    last_block_id = int(last_incbin.group(1))
    filename = str(last_incbin.group(2))
    last_block_offset = int(last_incbin.group(3), 16)
    out.write(
        f"""
rodata(TadData{last_block_id})
  insert __Tad_AudioData_{last_block_id}, "{filename}", {last_block_offset}

"""
    )

    out.write(f"assert(LoadAudioData & 0xffff == 0x{mapping.offset:04x})\n")
    out.write(f"assert(__Tad_AudioData_0 == LoadAudioData + {load_audio_data_size})\n")

    for i in range(1, last_block_id + 1):
        out.write(f"assert(__Tad_AudioData_{i} == LoadAudioData + 0x{i << 16:06x})\n")

    out.write("\n")

    out.write(f"constant Tad_Loader_Bin = __Tad_AudioData_0\n")
    out.write(f"constant Tad_Loader_Bin.size = {tad_loader_size}\n")
    out.write(f"constant Tad_AudioDriver_Bin = __Tad_AudioData_0 + {tad_loader_size}\n")
    out.write(f"constant Tad_AudioDriver_Bin.size = {tad_audiodriver_size}\n")
    out.write(f"constant Tad_DataTable = __Tad_AudioData_0 + {data_table_offset}\n")


def parse_arguments() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="TAD include generator for untech-engine"
    )

    parser.add_argument(
        "-o", "--output", required=True, help="output file (bass include file)"
    )

    parser.add_argument("project_file", help="TAD project file")

    parser.add_argument("ca65_asm_file", help="tad-compiler ca65-export assembly file")

    return parser.parse_args()


def main():
    args = parse_arguments()

    with open(args.project_file, "r") as f:
        tad_project = json.load(f)

    with open(args.ca65_asm_file, "r") as f:
        ca65_asm_file = f.read()

    out = StringIO()

    out.write(HEADER)
    generate_enums(tad_project, out)
    generate_asm(ca65_asm_file, out)

    with open(args.output, "w") as f:
        f.write(out.getvalue())


if __name__ == "__main__":
    main()
